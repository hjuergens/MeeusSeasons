<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>MeeusSeasons.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">MeeusSeasons</a> &gt; <a href="index.source.html" class="el_package">net.goldenbogen.lib.datetime</a> &gt; <span class="el_source">MeeusSeasons.java</span></div><h1>MeeusSeasons.java</h1><pre class="source lang-java linenums">package net.goldenbogen.lib.datetime;


import java.util.Calendar;
import java.util.Date;
import java.util.TimeZone;

/**
 * Class to calculate season for a given date.&lt;br&gt;
 * It makes heavy use of Meeus' astronmical algorithms &lt;i&gt;(Title of his book.)&lt;/i&gt;.
 * 
 * @author Pierre Goldenbogen &lt;br&gt;
 * email  pierre [at] goldenbogen [dot] net &lt;br&gt;
 * (c) Copyright by Pierre Goldenbogen, 2013
 */
<span class="nc" id="L16">public class MeeusSeasons {</span>

	/**
	 * Returns the value of the current season.
	 * 
	 * @return int = 1: Winter&lt;br&gt;
	 *         int = 2: Spring&lt;br&gt;
	 *         int = 3: Summer&lt;br&gt;
	 *         int = 4: Autumn
	 * @throws Exception description
	 */
	public static int getActualNorthernHemisphereSeason() throws Exception {
<span class="nc bnc" id="L28" title="All 2 branches missed.">		for (int iSeason = 1; iSeason &lt;= 4; iSeason++) {</span>
<span class="nc bnc" id="L29" title="All 2 branches missed.">			if (calcEquSol(iSeason, Calendar.getInstance().get(Calendar.YEAR)).getTime() &gt; new Date().getTime()) {</span>
<span class="nc" id="L30">				return iSeason;</span>
			}
		}
<span class="nc" id="L33">		return 0;</span>
	}

	public static int getNorthernHemisphereSeason(Date date) throws Exception {
<span class="fc" id="L37">		final Calendar calendar = Calendar.getInstance();</span>
<span class="fc" id="L38">		calendar.setTime(date);</span>
<span class="fc" id="L39">		final int year = calendar.get(Calendar.YEAR);</span>
<span class="fc bfc" id="L40" title="All 2 branches covered.">		for (int iSeason = 1; iSeason &lt;= 4; iSeason++) {</span>
<span class="fc bfc" id="L41" title="All 2 branches covered.">			if (calcEquSol(iSeason, year).getTime() &gt; date.getTime()) {</span>
<span class="fc" id="L42">				return iSeason;</span>
			}
		}
<span class="fc" id="L45">		return 0;</span>
	}
	/**
	 * Special implementation of the Math.cos function.
	 * 
	 * @param value a number
	 * @return double
	 */
	private static double specialCos(double value) {
<span class="fc" id="L54">		return Math.cos(value * Math.PI / 180);</span>
	}

	/**
	 * Calculate a single event for a single year (Either a Equiniox or Solstice)&lt;br&gt;
	 * &lt;i&gt;See Meeus Astronmical Algorithms Chapter 27&lt;/i&gt;
	 * 
	 * @param iSeason to calculate
	 * @param year for calculation
	 * @throws Exception
	 */
	private static Date calcEquSol(int iSeason, int year) throws Exception {
<span class="fc" id="L66">		int k = iSeason - 1;</span>
		// Initial estimate of date of event
<span class="fc" id="L68">		double ETA = init(k, year);</span>
<span class="fc" id="L69">		double T = (ETA - 2451545.0) / 36525;</span>
<span class="fc" id="L70">		double W = 35999.373 * T - 2.47;</span>
<span class="fc" id="L71">		double dL = 1.0 + 0.0334 * specialCos(W) + 0.0007 * specialCos(2 * W);</span>
<span class="fc" id="L72">		double S = periodic24(T);</span>
		// This is the answer in Julian Emphemeris Days
<span class="fc" id="L74">		double JDE = ETA + ((0.00001 * S) / dL);</span>
		// Convert Julian Days to TDT in a Date Object
<span class="fc" id="L76">		Date TDT = fromJDEToUTC(JDE);</span>
		// Correct TDT to UTC, both as Date Objects
<span class="fc" id="L78">		Date UTC = fromTDTToUTC(TDT);</span>
<span class="fc" id="L79">		return UTC;</span>
	}

	/**
	 * Calculate an initial guess as the ETA of the Equinox or Solstice of a given year.&lt;br&gt;
	 * &lt;b&gt;Valid for years 1000 to 3000!&lt;/b&gt;&lt;br&gt;
	 * &lt;br&gt;
	 * &lt;i&gt;See Meeus Astronmical Algorithms Chapter 27&lt;/i&gt;
	 * 
	 * @param k = season
	 * @param year for calculation
	 * @return
	 */
	private static double init(int k, int year) {
<span class="fc" id="L93">		double tmpYear = ((double) year - 2000) / 1000;</span>
<span class="fc" id="L94">		double result = 0.0;</span>
<span class="pc bpc" id="L95" title="1 of 5 branches missed.">		switch (k) {</span>
			case 0:
<span class="fc" id="L97">				result = 2451623.80984 + 365242.37404 * tmpYear + 0.05169 * Math.pow(tmpYear, 2) - 0.00411 * Math.pow(tmpYear, 3) - 0.00057 * Math.pow(tmpYear, 4);</span>
<span class="fc" id="L98">				break;</span>
			case 1:
<span class="fc" id="L100">				result = 2451716.56767 + 365241.62603 * tmpYear + 0.00325 * Math.pow(tmpYear, 2) + 0.00888 * Math.pow(tmpYear, 3) - 0.00030 * Math.pow(tmpYear, 4);</span>
<span class="fc" id="L101">				break;</span>
			case 2:
<span class="fc" id="L103">				result = 2451810.21715 + 365242.01767 * tmpYear - 0.11575 * Math.pow(tmpYear, 2) + 0.00337 * Math.pow(tmpYear, 3) + 0.00078 * Math.pow(tmpYear, 4);</span>
<span class="fc" id="L104">				break;</span>
			case 3:
<span class="fc" id="L106">				result = 2451900.05952 + 365242.74049 * tmpYear - 0.06223 * Math.pow(tmpYear, 2) - 0.00823 * Math.pow(tmpYear, 3) + 0.00032 * Math.pow(tmpYear, 4);</span>
<span class="fc" id="L107">				break;</span>
			default:
<span class="nc" id="L109">				result = 0.0;</span>
				break;
		}
<span class="fc" id="L112">		return result;</span>
	}

	/**
	 * Calculate 24 Periodic Terms.&lt;br&gt;
	 * &lt;br&gt;
	 * &lt;i&gt;See Meeus Astronmical Algorithms Chapter 27&lt;/i&gt;
	 * 
	 * @param T
	 * @return
	 */
	private static double periodic24(double T) {
<span class="fc" id="L124">		double result = 0.0;</span>
<span class="fc" id="L125">		double[] A = { 485, 203, 199, 182, 156, 136, 77, 74, 70, 58, 52, 50, 45, 44, 29, 18, 17, 16, 14, 12, 12, 12, 9, 8 };</span>
<span class="fc" id="L126">		double[] B = { 324.96, 337.23, 342.08, 27.85, 73.14, 171.52, 222.54, 296.72, 243.58, 119.81, 297.17, 21.02, 247.54, 325.15, 60.93, 155.12, 288.79, 198.04, 199.76, 95.39, 287.11, 320.81, 227.73, 15.45 };</span>
<span class="fc" id="L127">		double[] C = { 1934.136, 32964.467, 20.186, 445267.112, 45036.886, 22518.443, 65928.934, 3034.906, 9037.513, 33718.147, 150.678, 2281.226, 29929.562, 31555.956, 4443.417, 67555.328, 4562.452, 62894.029, 31436.921, 14577.848, 31931.756, 34777.259, 1222.114, 16859.074 };</span>

<span class="fc bfc" id="L129" title="All 2 branches covered.">		for (int i = 0; i &lt; 24; i++) {</span>
<span class="fc" id="L130">			result += A[i] * specialCos(B[i] + (C[i] * T));</span>
		}
<span class="fc" id="L132">		return result;</span>
	}

	/**
	 * Julian Date to UTC Date Object.&lt;br&gt;
	 * &lt;br&gt;
	 * &lt;i&gt;See Meeus Astronmical Algorithms Chapter 7&lt;/i&gt;
	 * 
	 * @param JDE = Julian date, possible with fractional days.
	 * @return Date = Output is a UTC date object.
	 */
	private static Date fromJDEToUTC(double JDE) {
<span class="fc" id="L144">		Date result = null;</span>
<span class="fc" id="L145">		int A = 0;</span>
<span class="fc" id="L146">		int alpha = 0;</span>

		// Integer (important) JDE's
<span class="fc" id="L149">		int Z = new Double(Math.floor(JDE + 0.5)).intValue();</span>
		// Fractional JDE's
<span class="fc" id="L151">		double F = (JDE + 0.5) - Z;</span>

<span class="pc bpc" id="L153" title="1 of 2 branches missed.">		if (Z &lt; 2299161) {</span>
<span class="nc" id="L154">			A = Z;</span>
		} else {
<span class="fc" id="L156">			alpha = new Double(Math.floor((Z - 1867216.25) / 36524.25)).intValue();</span>
<span class="fc" id="L157">			A = Z + 1 + alpha - new Double(Math.floor(alpha / 4)).intValue();</span>
		}
<span class="fc" id="L159">		int B = A + 1524;</span>
<span class="fc" id="L160">		int C = new Double(Math.floor((B - 122.1) / 365.25)).intValue();</span>
<span class="fc" id="L161">		int D = new Double(Math.floor(365.25 * C)).intValue();</span>
<span class="fc" id="L162">		int E = new Double(Math.floor((B - D) / 30.6001)).intValue();</span>

		// Day of month with decimals for time
<span class="fc" id="L165">		double DT = B - D - new Double(Math.floor(30.6001 * E)).intValue() + F;</span>

		// Month Number
<span class="pc bpc" id="L168" title="1 of 2 branches missed.">		int Mon = E - ((E &lt; 13.5) ? 1 : 13);</span>

		// Year 
<span class="pc bpc" id="L171" title="1 of 2 branches missed.">		int Yr = C - (((double) Mon &gt; 2.5) ? 4716 : 4715);</span>

		// Day of Month without decimals for time
<span class="fc" id="L174">		int Day = new Double(Math.floor(DT)).intValue();</span>

		// Hours and fractional hours
<span class="fc" id="L177">		double H = 24 * (DT - Day);</span>

		// Integer value of hours
<span class="fc" id="L180">		int Hr = new Double(Math.floor(H)).intValue();</span>

		// Minutes and fractional minutes
<span class="fc" id="L183">		double M = 60 * (H - Hr);</span>

		// Integer value of minutes
<span class="fc" id="L186">		int Min = new Double(Math.floor(M)).intValue();</span>

		// Integer value of seconds (Milliseconds discarded/cut away)
<span class="fc" id="L189">		int Sec = new Double(Math.floor(60 * (M - Min))).intValue();</span>

<span class="fc" id="L191">		Calendar cal = Calendar.getInstance(TimeZone.getTimeZone(&quot;UTC&quot;));</span>
<span class="fc" id="L192">		cal.set(Calendar.YEAR, Yr);</span>
<span class="fc" id="L193">		cal.set(Calendar.MONTH, Mon - 1);</span>
<span class="fc" id="L194">		cal.set(Calendar.DAY_OF_MONTH, Day);</span>
<span class="fc" id="L195">		cal.set(Calendar.HOUR_OF_DAY, Hr);</span>
<span class="fc" id="L196">		cal.set(Calendar.MINUTE, Min);</span>
<span class="fc" id="L197">		cal.set(Calendar.SECOND, Sec);</span>
<span class="fc" id="L198">		result = cal.getTime();</span>

<span class="fc" id="L200">		return result;</span>
	}

	/**
	 * Correct TDT to UTC.&lt;br&gt;
	 * &lt;br&gt;
	 * &lt;i&gt;See Meeus Astronmical Algorithms Chapter 10&lt;/i&gt;
	 * 
	 * @param TDT
	 * @return
	 * @throws Exception
	 */
	private static Date fromTDTToUTC(Date TDT) throws Exception {
<span class="fc" id="L213">		Date result = null;</span>
		// Range of years in lookup table.
<span class="fc" id="L215">		int tblFirstValue = 1620;</span>
<span class="fc" id="L216">		int tblLastValue = 2002;</span>

		// @formatter:off
		// Correction lookup table has entry for every even year between tblFirstValue and tblLastValue.
		// Corrections in Seconds!
<span class="fc" id="L221">		double[] table = {</span>
		/*1620*/121, 112, 103, 95, 88, 82, 77, 72, 68, 63, 60, 56, 53, 51, 48, 46, 44, 42, 40, 38,
		/*1660*/35, 33, 31, 29, 26, 24, 22, 20, 18, 16, 14, 12, 11, 10, 9, 8, 7, 7, 7, 7,
		/*1700*/7, 7, 8, 8, 9, 9, 9, 9, 9, 10, 10, 10, 10, 10, 10, 10, 10, 11, 11, 11,
		/*1740*/11, 11, 12, 12, 12, 12, 13, 13, 13, 14, 14, 14, 14, 15, 15, 15, 15, 15, 16, 16,
		/*1780*/16, 16, 16, 16, 16, 16, 15, 15, 14, 13,
		/*1800*/13.1, 12.5, 12.2, 12.0, 12.0, 12.0, 12.0, 12.0, 12.0, 11.9, 11.6, 11.0, 10.2, 9.2, 8.2,
		/*1830*/7.1, 6.2, 5.6, 5.4, 5.3, 5.4, 5.6, 5.9, 6.2, 6.5, 6.8, 7.1, 7.3, 7.5, 7.6,
		/*1860*/7.7, 7.3, 6.2, 5.2, 2.7, 1.4, -1.2, -2.8, -3.8, -4.8, -5.5, -5.3, -5.6, -5.7, -5.9,
		/*1890*/-6.0, -6.3, -6.5, -6.2, -4.7, -2.8, -0.1, 2.6, 5.3, 7.7, 10.4, 13.3, 16.0, 18.2, 20.2,
		/*1920*/21.1, 22.4, 23.5, 23.8, 24.3, 24.0, 23.9, 23.9, 23.7, 24.0, 24.3, 25.3, 26.2, 27.3, 28.2,
		/*1950*/29.1, 30.0, 30.7, 31.4, 32.2, 33.1, 34.0, 35.0, 36.5, 38.3, 40.2, 42.2, 44.5, 46.5, 48.5,
		/*1980*/50.5, 52.5, 53.8, 54.9, 55.8, 56.9, 58.3, 60.0, 61.6, 63.0, 63.8, 64.3 };/*2002 last entry*/
		// @formatter:on

		/*
		 *  Values for deltaT for 2000 thru 2002 from NASA.
		 */

		// deltaT = TDT - UTC (in Seconds).
<span class="fc" id="L241">		double deltaT = 0.0;</span>
<span class="fc" id="L242">		Calendar cal = Calendar.getInstance(TimeZone.getTimeZone(&quot;UTC&quot;));</span>
<span class="fc" id="L243">		cal.setTime(TDT);</span>
<span class="fc" id="L244">		int Year = cal.get(Calendar.YEAR);</span>

		// Centuries from the epoch 2000.0
<span class="fc" id="L247">		double t = (Year - 2000.0) / 100.0;</span>

		/*
		 *  Find correction in table.
		 */
<span class="pc bpc" id="L252" title="2 of 4 branches missed.">		if (Year &gt;= tblFirstValue &amp;&amp; Year &lt;= tblLastValue) {</span>
			// Odd year - interpolate.
<span class="nc bnc" id="L254" title="All 2 branches missed.">			if (Year % 2 != 0) {</span>
<span class="nc" id="L255">				deltaT = table[(Year - tblFirstValue - 1) / 2] + table[(Year - tblLastValue + 1 / 2)] / 2;</span>
			} else {
				// Even year - direct table lookup.
<span class="nc" id="L258">				deltaT = table[(Year - tblFirstValue) / 2];</span>
			}
<span class="pc bpc" id="L260" title="1 of 2 branches missed.">		} else if (Year &lt; 948) {</span>
<span class="nc" id="L261">			deltaT = 2177 + 497 * t + 44.1 * Math.pow(t, 2);</span>
<span class="pc bpc" id="L262" title="1 of 2 branches missed.">		} else if (Year &gt;= 948) {</span>
<span class="fc" id="L263">			deltaT = 102.0 + 102.0 * t + 25.3 * Math.pow(t, 2);</span>
			// Special correction to avoid discontinuity in 2000.
<span class="pc bpc" id="L265" title="2 of 4 branches missed.">			if (Year &gt;= 2000 &amp;&amp; Year &lt;= 2100) {</span>
<span class="fc" id="L266">				deltaT += 0.37 * (Year - 2100);</span>
			}
		} else {
<span class="nc" id="L269">			throw new Exception(&quot;Error: TDT to UTC correction not computed.&quot;);</span>
		}
<span class="fc" id="L271">		cal.setTimeInMillis(TDT.getTime() - (long) (deltaT * 1000));</span>
<span class="fc" id="L272">		result = cal.getTime();</span>

<span class="fc" id="L274">		return result;</span>
	}

	/**
	 * Returns the name of the season specified by an id
	 * @param season id
	 * @return name of season
     */
	public static String name(int season) {
<span class="nc bnc" id="L283" title="All 5 branches missed.">		switch (season) {</span>
			case 1:
<span class="nc" id="L285">				return &quot;Winter&quot;;</span>
			case 2:
<span class="nc" id="L287">				return &quot;Spring&quot;;</span>
			case 3:
<span class="nc" id="L289">				return &quot;Summer&quot;;</span>
			case 4:
<span class="nc" id="L291">				return &quot;Autumn&quot;;</span>
			default:
<span class="nc" id="L293">				throw new RuntimeException(&quot;unknown season id&quot;);</span>
		}
	}

	/**
	 * Test method to print out what season we actually have.
	 * 
	 * @param args command line arguments
	 */
	public static void main(String[] args) {
		try {
<span class="nc" id="L304">			int season = getActualNorthernHemisphereSeason();</span>
<span class="nc" id="L305">			System.out.println(name(season));</span>
<span class="nc" id="L306">		} catch (Exception e) {</span>
<span class="nc" id="L307">			e.printStackTrace();</span>
<span class="nc" id="L308">		}</span>
<span class="nc" id="L309">	}</span>
}

</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.7.8.201612092310</span></div></body></html>